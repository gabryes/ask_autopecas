// public/js/dashboard.js
// Certifique-se de que a biblioteca Chart.js est√° carregada antes deste script no HTML.
// Por exemplo, adicionando <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> no <head> ou antes de </body>.

// Estado global do dashboard
let dashboardData = {
    stats: {},
    conversations: [],
    activity: [],
    categories: []
};

// Inst√¢ncias dos gr√°ficos (para poder destru√≠-los e recri√°-los ao atualizar)
let activityChartInstance = null;
let categoriesChartInstance = null;

// Inicializa√ß√£o
document.addEventListener('DOMContentLoaded', function() {
    initializeDashboard();
    loadDashboardData();
    // Reativa√ß√£o do auto-refresh para buscar dados atualizados a cada 30 segundos
    startAutoRefresh(); 
    // Detectar mudan√ßas de conex√£o (melhoria anterior)
    window.addEventListener('online', () => {
        console.log('üåê Conex√£o restaurada');
        loadDashboardData();
    });
    window.addEventListener('offline', () => {
        console.log('üì¥ Conex√£o perdida');
        updateSystemStatus('Offline', 'error');
    });
});

function initializeDashboard() {
    console.log('üéØ Dashboard inicializado');
    updateSystemStatus('Carregando...', 'connecting');
}

// Carregar todos os dados do dashboard
async function loadDashboardData() {
    try {
        // Obtenha a refer√™ncia ao ServiceManager injetado no app.locals pelo Server.js
        // const serviceManager = window.serviceManager; // Se ServiceManager fosse global no navegador

        // Para obter o status real (uptime, mem√≥ria, etc) diretamente via API.
        // O ServiceManager no backend j√° agrupa essas informa√ß√µes em /api/control/status
        const statusResponse = await fetch('/api/control/status');
        const statusData = await statusResponse.json();

        // Carregar estat√≠sticas
        const statsResponse = await fetch('/api/stats');
        const statsData = await statsResponse.json();
        
        // Carregar conversas recentes
        const conversationsResponse = await fetch('/api/conversations/recent');
        const conversationsData = await conversationsResponse.json();
        
        // Carregar dados de atividade
        const activityResponse = await fetch('/api/analytics/activity');
        const activityData = await activityResponse.json();
        
        // Carregar categorias
        const categoriesResponse = await fetch('/api/analytics/categories');
        const categoriesData = await categoriesResponse.json();
        
        // Atualizar dados globais do dashboard
        dashboardData = {
            stats: statsData,
            conversations: conversationsData.conversations || [],
            activity: activityData.data || [],
            categories: categoriesData.categories || []
        };

        // Adicionar informa√ß√µes de sistema do ServiceManager ao dashboardData.stats
        if (statusData && statusData.system) {
            dashboardData.stats.system = statusData.system;
            // Atualiza o status do sistema na header com o status dos servi√ßos.
            const mainServiceStatus = statusData.services && statusData.services.api ? statusData.services.api.status : 'unknown';
            updateSystemStatus(mainServiceStatus, mainServiceStatus);
        }
        
        // Atualizar interface do dashboard
        updateDashboard();
        
    } catch (error) {
        console.error('‚ùå Erro ao carregar dados do dashboard:', error);
        updateSystemStatus('Erro', 'error');
        showErrorMessage('Erro ao carregar dados do dashboard. Verifique a conex√£o com o servidor.');
    }
}

// Atualiza todas as se√ß√µes do dashboard
function updateDashboard() {
    updateStats();
    updateSystemInfo();
    updateConversations();
    updateActivityChart(); // Chama a fun√ß√£o que usa Chart.js
    updateCategoriesChart(); // Chama a fun√ß√£o que usa Chart.js
    updateSystemStatus('Online', 'running');
}

// Atualizar estat√≠sticas principais (cards)
function updateStats() {
    const { stats } = dashboardData;
    
    // Total de Conversas
    const totalConversationsElement = document.getElementById('totalConversations');
    if (totalConversationsElement) {
        totalConversationsElement.textContent = stats.conversations?.total?.toLocaleString() || '0';
    }

    // Total de Leads
    const totalLeadsElement = document.getElementById('totalLeads');
    if (totalLeadsElement) {
        totalLeadsElement.textContent = stats.leads?.total?.toLocaleString() || '0';
    }
    
    // Conversas Ativas
    const activeConversationsElement = document.getElementById('activeConversations');
    if (activeConversationsElement) {
        activeConversationsElement.textContent = stats.conversations?.active?.toLocaleString() || '0';
        const activeIndicator = document.getElementById('activeIndicator');
        if (activeIndicator) {
            activeIndicator.className = `stat-indicator ${stats.conversations?.active > 0 ? 'running' : 'stopped'}`;
        }
    }

    // Escaladas Hoje
    const escalationsTodayElement = document.getElementById('escalationsToday');
    if (escalationsTodayElement) {
        escalationsTodayElement.textContent = stats.escalations?.today?.toLocaleString() || '0';
        const escalationIndicator = document.getElementById('escalationIndicator');
        if (escalationIndicator) {
            escalationIndicator.className = `stat-indicator ${stats.escalations?.today > 0 ? 'stopped' : 'running'}`; // 'stopped' para indicar algo a ser resolvido
        }
    }
}

// Atualizar informa√ß√µes do sistema (no header e na se√ß√£o 'Informa√ß√µes do Sistema')
function updateSystemInfo() {
    const { stats } = dashboardData;
    
    if (stats.system) {
        // Uptime no header
        const systemUptimeElement = document.getElementById('systemUptime');
        if (systemUptimeElement) {
            systemUptimeElement.textContent = stats.system.uptime || '--';
        }
        
        // Informa√ß√µes detalhadas do sistema na se√ß√£o
        const systemInfoElement = document.getElementById('systemInfo');
        if (systemInfoElement) {
            const formatMemory = (bytes) => {
                return bytes ? (bytes / 1024 / 1024).toFixed(2) + ' MB' : 'N/A';
            };
            
            systemInfoElement.innerHTML = `
                <div class="info-item">
                    <div class="info-label">Produtos no Cat√°logo</div>
                    <div class="info-value">${stats.catalog?.total_products?.toLocaleString() || '0'}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Categorias de Produtos</div>
                    <div class="info-value">${stats.catalog?.categories?.toLocaleString() || '0'}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Mem√≥ria Usada (RSS)</div>
                    <div class="info-value">${formatMemory(stats.system.memory?.rss)}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Node.js Vers√£o</div>
                    <div class="info-value">${stats.system.node_version || 'N/A'}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Plataforma</div>
                    <div class="info-value">${stats.system.platform || 'N/A'}</div>
                </div>
                 <div class="info-item">
                    <div class="info-label">PID</div>
                    <div class="info-value">${stats.system.pid || 'N/A'}</div>
                </div>
            `;
        }
    }
}

// Atualizar conversas recentes
function updateConversations() {
    const conversationsElement = document.getElementById('recentConversations');
    if (!conversationsElement) return;

    const getStatusIcon = (status) => {
        switch(status) {
            case 'active': return 'üü¢';
            case 'waiting': return 'üü°'; // Voc√™ pode definir este status para Leads que esperam uma resposta
            case 'completed': return '‚úÖ';
            case 'escalated': return 'üî¥';
            case 'new': return 'üîµ'; // Para novos leads/conversas
            case 'qualified': return 'üü£'; // Para leads qualificados
            case 'quoted': return 'üü†'; // Para leads com or√ßamento enviado
            case 'converted': return '‚≠ê'; // Para leads convertidos
            case 'lost': return '‚ö´'; // Para leads perdidos
            default: return '‚ö™';
        }
    };
    
    const formatTime = (isoString) => {
        const date = new Date(isoString);
        const now = new Date();
        const diffMinutes = Math.floor((now - date) / (1000 * 60));
        
        if (diffMinutes < 1) return 'Agora';
        if (diffMinutes < 60) return `H√° ${diffMinutes}m`;
        const diffHours = Math.floor(diffMinutes / 60);
        if (diffHours < 24) return `H√° ${diffHours}h`;
        return date.toLocaleDateString('pt-BR'); // Formato da data para o Brasil
    };
    
    if (dashboardData.conversations.length > 0) {
        conversationsElement.innerHTML = dashboardData.conversations.map(conv => `
            <div class="activity-item">
                <div class="activity-icon">${getStatusIcon(conv.status)}</div>
                <div class="activity-content">
                    <div class="activity-title">${conv.name || conv.contact}</div>
                    <div class="activity-subtitle">${conv.lastMessage}</div>
                    <div class="activity-time">${formatTime(conv.timestamp)}</div>
                </div>
            </div>
        `).join('');
    } else {
        conversationsElement.innerHTML = '<div class="activity-item"><div class="activity-content">Nenhuma conversa recente encontrada.</div></div>';
    }
}

// Atualizar gr√°fico de atividade com Chart.js
function updateActivityChart() {
    const ctx = document.getElementById('activityChartCanvas');
    if (!ctx) return;

    // Destroi a inst√¢ncia anterior do gr√°fico se existir
    if (activityChartInstance) {
        activityChartInstance.destroy();
    }

    const labels = dashboardData.activity.map(d => d.day);
    const data = dashboardData.activity.map(d => d.conversations);

    activityChartInstance = new Chart(ctx, {
        type: 'bar', // Tipo de gr√°fico: barras
        data: {
            labels: labels,
            datasets: [{
                label: 'Total de Conversas',
                data: data,
                backgroundColor: 'rgba(102, 126, 234, 0.7)', // Cor das barras
                borderColor: 'rgba(102, 126, 234, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false, // Permite que o gr√°fico se adapte ao tamanho do cont√™iner
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function(value) { if (value % 1 === 0) return value; } // Apenas n√∫meros inteiros
                    }
                }
            },
            plugins: {
                legend: {
                    display: false // N√£o exibir a legenda do dataset
                },
                title: {
                    display: true,
                    text: 'Atividade do Chatbot nos √öltimos 7 Dias',
                    font: { size: 16 }
                }
            }
        }
    });
}

// Atualizar gr√°fico de categorias com Chart.js
function updateCategoriesChart() {
    const ctx = document.getElementById('categoriesChartCanvas');
    if (!ctx) return;

    // Destroi a inst√¢ncia anterior do gr√°fico se existir
    if (categoriesChartInstance) {
        categoriesChartInstance.destroy();
    }

    const labels = dashboardData.categories.map(c => c.name);
    const data = dashboardData.categories.map(c => c.count);

    categoriesChartInstance = new Chart(ctx, {
        type: 'pie', // Tipo de gr√°fico: pizza
        data: {
            labels: labels,
            datasets: [{
                label: 'N√∫mero de Produtos',
                data: data,
                backgroundColor: [
                    '#667eea', // Roxo claro
                    '#764ba2', // Roxo escuro
                    '#a266ea', // Roxo vibrante
                    '#ea667e', // Rosa
                    '#ea764b', // Laranja
                    '#4b76ea', // Azul vibrante
                    '#66ea7e'  // Verde claro
                ],
                hoverOffset: 4
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right', // Posiciona a legenda √† direita
                },
                title: {
                    display: true,
                    text: 'Distribui√ß√£o de Produtos por Categoria',
                    font: { size: 16 }
                }
            }
        }
    });
}

// Atualizar status geral do sistema (no header)
function updateSystemStatus(status, type) {
    const statusElement = document.getElementById('systemStatus');
    if (statusElement) {
        statusElement.textContent = status === 'running' ? 'Online' : (status === 'stopped' ? 'Offline' : 'Verificando...');
        statusElement.className = `stat-value ${type}`;
    }
}

// Mostrar mensagem de erro tempor√°ria
function showErrorMessage(message) {
    const dashboardMain = document.querySelector('.dashboard-main');
    if (!dashboardMain) return;

    let errorDiv = document.getElementById('dashboard-error-message');
    if (!errorDiv) {
        errorDiv = document.createElement('div');
        errorDiv.id = 'dashboard-error-message';
        errorDiv.className = 'alert error';
        dashboardMain.prepend(errorDiv);
    }
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';

    setTimeout(() => {
        errorDiv.style.display = 'none';
    }, 5000);
}

// Refresh manual do dashboard
async function refreshDashboard() {
    const refreshBtn = document.getElementById('refreshBtn');
    if (refreshBtn) {
        refreshBtn.textContent = 'üîÑ Atualizando...';
        refreshBtn.disabled = true;
    }
    
    // Chama o recarregamento de dados
    await loadDashboardData();
    
    if (refreshBtn) {
        refreshBtn.textContent = 'üîÑ Atualizar';
        refreshBtn.disabled = false;
    }
}

// Inicia o auto-refresh a cada 30 segundos
function startAutoRefresh() {
    setInterval(loadDashboardData, 30000);
    console.log('üîÑ Auto-refresh do dashboard iniciado (a cada 30 segundos)');
}
